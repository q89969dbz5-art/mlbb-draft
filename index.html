<!-- Save as mlbb-roamer-v6.html and open in a browser -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MLBB Draft — v6 (Gold Roamer Tab Edition)</title>

<link rel="manifest" href="manifest.json">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js')
      .then(() => console.log('✅ Service Worker registered'))
      .catch(err => console.log('❌ Service Worker failed', err));
  }
</script>

<style>
  :root{
    --bg:#061025; --card:#0b1220; --muted:#9aa6bb; --accent:#66e0b3;
    --danger:#ff6b6b; --good:#66e0b3; --bad:#ff7a7a;
    --gold:#ffd700;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
.banned { color:#ff5555; font-weight:700; }
  }
  body{background:linear-gradient(180deg,#04101a 0%, #071028 100%); color:#e6eef8; margin:0; padding:18px;}
  .wrap{max-width:1200px;margin:0 auto;}
  h1{margin:0 0 6px;font-size:20px}
  .lead{color:var(--muted); margin:0 0 12px; font-size:13px}
  .card{background:var(--card); padding:12px; border-radius:10px; box-shadow: 0 8px 28px rgba(0,0,0,0.55); margin-bottom:12px}
  .tabs{display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap}
  .tab{padding:8px 12px; border-radius:8px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--muted)}
  .tab.active{background:linear-gradient(90deg, rgba(102,224,179,0.06), transparent); color:var(--accent); border-color:rgba(102,224,179,0.12)}
  .tab.roamer{ color:var(--gold); border-color: rgba(255,215,0,0.12); }
  .tab.roamer.active{ background: linear-gradient(90deg, rgba(255,215,0,0.06), transparent); color:var(--gold); border-color: rgba(255,215,0,0.22); box-shadow: 0 6px 18px rgba(255,215,0,0.06); }
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type="text"], input[type="number"], select, textarea {padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit}
  button{background:var(--accent); color:#022; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700}
  button.ghost{background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted)}
  table{width:100%; border-collapse:collapse; margin-top:8px}
  th,td{padding:8px 10px; text-align:left; font-size:13px; vertical-align:top}
  th{color:var(--muted); font-size:12px; text-transform:uppercase}
  tr.recommended{outline:3px solid rgba(102,224,179,0.08); background:linear-gradient(90deg, rgba(102,224,179,0.02), transparent)}
  tr.removed{opacity:0.45}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  .tally{background:rgba(255,255,255,0.015); border-radius:8px; padding:8px; margin-top:6px}
  .tally-row{display:flex; justify-content:space-between; gap:10px; padding:2px 0; font-size:13px}
  .tally-row .k{color:var(--muted); width:60%}
  .tally-row .v{width:40%; text-align:right; font-weight:700}
  .total-hero{margin-top:8px; padding:8px; border-radius:8px; background:linear-gradient(90deg, rgba(102,224,179,0.04), transparent); font-weight:800; display:flex; justify-content:space-between}
  .score-neg{color:var(--bad)}
  .score-pos{color:var(--good)}
  .grid{display:grid; grid-template-columns: 1fr 420px; gap:12px}
  .uncompat{color:#ffb3b3; font-weight:700}
  .compat{color:var(--accent); font-weight:700}
  .hint{font-size:12px;color:var(--muted); margin-top:6px}
  .small-btn{padding:6px 8px; font-size:13px; border-radius:6px}
  .detail-line{font-size:12px; color:var(--muted);}
  .reverse-tag{font-size:12px; color:#ffd88f; margin-left:6px}
  .rec-box{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02); margin-top:8px;}
  .rec-box.glow{ box-shadow: 0 6px 30px rgba(255,215,0,0.12); border:1px solid rgba(255,215,0,0.12); }
  @media(max-width:980px){ .grid{grid-template-columns: 1fr} .tally{margin-bottom:10px} }
  @keyframes glowPulse {
  0% { box-shadow: 0 0 8px rgba(255,215,0,0.2); }
  50% { box-shadow: 0 0 22px rgba(255,215,0,0.5); }
  100% { box-shadow: 0 0 8px rgba(255,215,0,0.2); }
}
.rec-box.glow {
  animation: glowPulse 2s infinite;
}
  /* --- Sticky Recommendation Panel --- */
#recommendation {
  position: sticky;
  bottom: 12px;
  background: var(--card);
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 6px 22px rgba(0,0,0,0.3);
  z-index: 10;
}
</style>
</head>
<body>
<div class="wrap">
  <h1>MLBB Draft — v6</h1>
  <p class="lead">Gold Roamer tab added. Live two-way scoring and inline reverse tags remain. Recommended pick will glow gold when Roamer tab is active.</p>

  <div class="card">
    <div class="tabs" id="roleTabs"></div>
    <div class="controls" style="margin-top:6px; align-items:center;">
      <div style="min-width:300px">
        <label class="small">Ally picks (live)</label><br/>
        <input id="allyPicks" type="text" placeholder="e.g. Tigreal, Angela, Brody" style="width:100%">
      </div>
      <div style="min-width:300px">
        <label class="small">Enemy picks (live)</label><br/>
        <input id="enemyPicks" type="text" placeholder="e.g. Gatot, Lolita, Hilda" style="width:100%">
      </div>
  <div style="min-width:260px">
  <label class="small">Banned heroes</label><br/>
  <input id="bannedPicks" type="text" placeholder="e.g. Valentina, Franco" style="width:100%">
</div>
      <div style="margin-left:8px">
        <div class="hint">Tip: for lists use commas — archetypes: Pick-off, Teamfight, Split Push/Cover</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px">
      <input type="text" id="filter" placeholder="Filter by name" style="width:260px">
      <div style="flex:1"></div>
      <label class="small" style="margin-right:10px"><input type="checkbox" id="debugToggle"> Show detail lines</label>
      <button id="saveLocal" class="ghost">Save</button>
      <button id="loadLocal" class="ghost">Load</button>
      <button id="exportCsv" class="ghost">Export CSV</button>
      <button id="exportBackup" class="ghost">⬇️ Export Backup</button>
<input type="file" id="importBackup" accept=".json" style="display:none">
<label for="importBackup" class="ghost" style="cursor:pointer;">⬆️ Import Backup</label>
    </div>

    <div class="grid">
      <div style="overflow:auto; max-height:64vh;">
        <table>
          <thead>
            <tr>
              <th>Hero</th>
              <th>Role</th>
              <th>Archetype</th>
              <th>Hard Counter</th>
              <th>Soft Counter</th>
              <th>Counters</th>
              <th>Total</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="heroesTable"></tbody>
        </table>
      </div>

      <div>
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <h3 style="margin:0">Tallies — role view</h3>
              <div class="small muted">Tally list shows heroes for the active tab (or all for 'All').</div>
            </div>
            <div><button id="clearInputs" class="ghost">Clear Ally/Enemy</button></div>
          </div>

          <div id="tallyList" style="margin-top:12px; max-height:58vh; overflow:auto;"></div>
          <div id="recommendation" style="margin-top:12px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* v6 - Gold Roamer Tab Edition (surgically updated)
   - Map UI removed
   - Comfort/compatible removed
   - Table adjusted: HERO | ROLE | ARCHETYPE | HARD COUNTER | SOFT COUNTER | COUNTERS
   - Archetype triangle scoring added
   - Hard/Soft counter scoring implemented
*/

// ---------- Prefill sample (surgically adapted) ----------
let heroes = [
  {name:'Chip', role:'Tank', group:'Meta', archetype:'Teamfight', hard_counters:['Gatot'], soft_counters:[], counters:['Alucard']},
  {name:'Alucard', role:'Assassin', group:'Unknown', archetype:'Pick-off', hard_counters:['Gatot','Chip'], soft_counters:[], counters:['Kalea']},
  {name:'Gatot', role:'Tank', group:'Meta', archetype:'Teamfight', hard_counters:[], soft_counters:[], counters:['Alucard']},
  {name:'Kalea', role:'Support', group:'Playable', archetype:'Teamfight', hard_counters:['Alucard'], soft_counters:[], counters:[]},
  {name:'Franco', role:'Tank', group:'Situational', archetype:'Pick-off', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Angela', role:'Support', group:'Playable', archetype:'Teamfight', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Tigreal', role:'Tank', group:'Playable', archetype:'Teamfight', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Chou', role:'Fighter', group:'Situational', archetype:'Pick-off', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Badang', role:'Fighter', group:'Situational', archetype:'Split Push/Cover', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Granger', role:'Marksman', group:'Meta', archetype:'Pick-off', hard_counters:[], soft_counters:[], counters:[]},
  {name:'Cyclops', role:'Mage', group:'Unknown', archetype:'Pick-off', hard_counters:[], soft_counters:[], counters:[]}
];

const ROLE_TABS = ['All','Tank','Assassin','Fighter','Mage','Marksman','Support','Roamer'];
let activeTab = 'All';
const extraRoamers = ['chou','badang','khaleed','kaja'];

  function isRoamerHero(h){
  const r = h.role.toLowerCase();
  const n = norm(h.name);

  // Tank or Support OR inside extraRoamers list
  return r === "tank" || r === "support" || extraRoamers.includes(n);
}

let allyList = [], enemyList = [];
let bannedList = [];

// helpers
function norm(s){ return String(s||'').trim().replace(/\s+/g,' ').toLowerCase(); }
function parseList(s){ return String(s||'').split(',').map(x=>x.trim()).filter(Boolean); }

// ---------- computeTotals (replaced) ----------
const archetypeTriangle = {
  'teamfight': 'pick-off',          // teamfight COUNTERS pick-off
  'pick-off': 'split push/cover',   // pick-off COUNTERS split
  'split push/cover': 'teamfight'   // split COUNTERS teamfight
};

function determineComposition(list){
  const counts = {};
  list.forEach(name => {
    const h = heroes.find(x => norm(x.name) === norm(name));
    if(!h) return;
    const a = (h.archetype || '').toString().trim().toLowerCase();
    if(!a) return;
    counts[a] = (counts[a] || 0) + 1;
  });
  // composition is any archetype with 2 or more heroes
  for(const k of Object.keys(counts)){
    if(counts[k] >= 2) return k;
  }
  return null;
}

function computeTotals(){
  const nameMap = {}; heroes.forEach(h=> nameMap[norm(h.name)] = h);
  const enemyComposition = determineComposition(enemyList);
  const allyComposition = determineComposition(allyList);

  heroes.forEach(h => {
    h._details = { forward:[], reverse:[], total:0 };
    h.disabled = !!(Array.isArray(bannedList) && bannedList.find(b => norm(b) === norm(h.name)));
    h.total = 0;
  });

  // Forward pass: counters hero defines (hero.counters / hero.hard_counters / hero.soft_counters)
  heroes.forEach(h => {
    if(h.disabled) return;
    // ensure arrays exist
    h.counters = Array.isArray(h.counters) ? h.counters : [];
    h.hard_counters = Array.isArray(h.hard_counters) ? h.hard_counters : [];
    h.soft_counters = Array.isArray(h.soft_counters) ? h.soft_counters : [];
    const heroNameNorm = norm(h.name);

    // For each enemy pick
    enemyList.forEach(en => {
      const enNorm = norm(en);
      // If this hero directly counters that enemy (hard)
      if(h.hard_counters.find(c=> norm(c) === enNorm)){
        h.total -= 4;
        h._details.forward.push({label:`Counters (hard) ${en}`, pts:-4});
      } else if(h.counters.find(c => norm(c) === enNorm)){
        // counters[] treated as softer positive
        h.total -= 1;
        h._details.forward.push({label:`Counters ${en}`, pts:-1});
      }

      // If this hero soft-counters that enemy (soft_counters)
      if(h.soft_counters.find(c => norm(c) === enNorm)){
        h.total -= 2;
        h._details.forward.push({label:`SoftCounters ${en}`, pts:-2});
      }

      // If enemy counters this hero (enemy.hard_counters includes this hero) => penalty -4
      const enHero = nameMap[enNorm];
      if(enHero){
        if(Array.isArray(enHero.hard_counters) && enHero.hard_counters.find(x => norm(x) === heroNameNorm)){
          h.total += 4;
          h._details.forward.push({label:`Hard-countered-by ${en}`, pts:4});
        }
        // enemy soft counters this hero => -2
        if(Array.isArray(enHero.soft_counters) && enHero.soft_counters.find(x => norm(x) === heroNameNorm)){
          h.total += 2;
          h._details.forward.push({label:`Soft-countered-by ${en}`, pts:2});
        }
      }
    });

    // Archetype interactions (triangle)
    const myArc = (h.archetype || '').toString().trim().toLowerCase();
    if(enemyComposition && myArc){
      // If my archetype COUNTERS the enemy composition => +1
      if(archetypeTriangle[myArc] === enemyComposition){
        h.total += 1;
        h._details.forward.push({label:`Archetype adv vs ${enemyComposition}`, pts:+1});
      }
      // If enemy composition counters my archetype => -1
      if(archetypeTriangle[enemyComposition] === myArc){
        h.total += -1;
        h._details.forward.push({label:`Archetype disadv vs ${enemyComposition}`, pts:-1});
      }
    }

    h._details.total = h.total;
  });

  // Reverse pass: enemy picks give reverse effects for heroes that are listed as counters on enemy heroes
  enemyList.forEach(en => {
    const enHero = nameMap[norm(en)];
    if(!enHero) return;
    (enHero.counters || []).forEach(targetName => {
      const target = nameMap[norm(targetName)];
      if(!target || target.disabled) return;
      target._details.reverse = target._details.reverse || [];
      // enemy lists target in their counters -> target gets a reverse negative (treated as -3)
      target._details.reverse.push({label:`Rev Counter (enemy ${en})`, pts:-3});
      target.total += -3;
      target._details.total = target.total;
    });
  });

  return { enemyComposition, allyComposition };
}

// decision logic: picks from roamer-eligible heroes only
function decidePick(){
  computeTotals();
  const pool = heroes.filter(h=> !h.disabled && isRoamerHero(h));
  if(pool.length===0) return {pickIdx:-1, reason:'No eligible roamer heroes.'};
  const sorted = pool.slice().sort((a,b)=> b.total - a.total);
  const top = sorted[0];
  const topMetaList = heroes.filter(h=> !h.disabled && isRoamerHero(h) && norm(h.group)==='meta');
  const topMeta = topMetaList.length ? topMetaList.reduce((a,b)=> a.total>b.total? a : b, sorted[0]) : top;
  const group = norm(top.group||'');
  if(group==='meta') return {pickIdx: heroes.indexOf(top), reason:`Top hero is Meta (${top.name} ${top.total}).`};
  if(group==='situational'){ if(top.total >= (topMeta.total + 2)) return {pickIdx: heroes.indexOf(top), reason:`Situational ${top.name} >= top Meta +2 (${top.total} >= ${topMeta.total + 2}).`}; else return {pickIdx: heroes.indexOf(topMeta), reason:`Situational ${top.name} did NOT exceed top Meta +2 → pick ${topMeta.name}.`}; }
  if(group==='playable'){ if(top.total >= (topMeta.total + 3)) return {pickIdx: heroes.indexOf(top), reason:`Playable ${top.name} >= top Meta +3 (${top.total} >= ${topMeta.total + 3}).`}; else return {pickIdx: heroes.indexOf(topMeta), reason:`Playable ${top.name} did NOT exceed top Meta +3 → pick ${topMeta.name}.`}; }
  return {pickIdx: heroes.indexOf(top), reason:'Fallback pick.'};
}

// ---------- UI ----------
const roleTabsEl = document.getElementById('roleTabs');
ROLE_TABS.forEach(tabName => {
  const btn = document.createElement('button');
  btn.className = 'tab' + (tabName==='Roamer' ? ' roamer' : '') + (tabName===activeTab ? ' active' : '');
  btn.textContent = tabName;
  btn.onclick = () => { activeTab = tabName; document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active')); btn.classList.add('active'); render(); };
  roleTabsEl.appendChild(btn);
});

const heroesTable = document.getElementById('heroesTable');
const tallyList = document.getElementById('tallyList');
const recommendationBox = document.getElementById('recommendation');

function roleFilter(h){
  if(activeTab === 'All') return true;
  if(activeTab === 'Roamer') return isRoamerHero(h);
  return norm(h.role) === norm(activeTab);
}

function render(){
  const filterText = (document.getElementById('filter').value||'').trim().toLowerCase();
  const dec = computeTotals();

  // left table
  heroesTable.innerHTML = '';
  const visible = heroes.filter(h => roleFilter(h) && (filterText === '' || norm(h.name).includes(filterText)));
  visible.forEach(h => {
    const idx = heroes.indexOf(h);
    const tr = document.createElement('tr');
    if(h.disabled) tr.classList.add('removed');

    const maps = (h.maps||[]).join(', ');
    const countered = (h.countered_by||[]).join(', ');
    const compatRaw = Array.isArray(h.compatible) ? h.compatible.join(', ') : (h.compatible||'');
    const counters = (h.counters||[]).join(', ');

    tr.innerHTML = `
      <td><input data-idx="${idx}" data-key="name" value="${escapeHtml(h.name)}" style="width:120px"></td>
      <td><input data-idx="${idx}" data-key="role" value="${escapeHtml(h.role)}" style="width:80px"></td>
      <td>
       <input data-idx="${idx}" data-key="archetype" 
       value="${h.archetype}" 
       placeholder="Pick-off, Teamfight" />
      </td>
      <td><input data-idx="${idx}" data-key="hard_counters" value="${(h.hard_counters||[]).join(', ')}" style="width:140px"></td>
      <td><input data-idx="${idx}" data-key="soft_counters" value="${(h.soft_counters||[]).join(', ')}" style="width:140px"></td>
      <td><input data-idx="${idx}" data-key="counters" value="${(h.counters||[]).join(', ')}" style="width:140px"></td>
      <td><strong>${h.disabled? 'REMOVED' : (typeof h.total==='number' ? h.total : '0')}</strong></td>
      <td>
        <div style="display:flex; gap:6px;">
          <button data-action="dup" data-idx="${idx}" class="ghost">⧉</button>
          <button data-action="rm" data-idx="${idx}" class="ghost">✖</button>
        </div>
      </td>
    `;
    heroesTable.appendChild(tr);
  });

  // attach listeners in table
  heroesTable.querySelectorAll('input,select,button').forEach(el=>{
    const idx = el.dataset.idx; if(typeof idx === 'undefined') return;
    const key = el.dataset.key;
    if(el.tagName === 'INPUT' && el.type === 'text'){
      el.onblur = e => {
        const val = e.target.value;
        if(key === 'name') heroes[idx].name = val.trim();
        else if(key === 'hard_counters' || key === 'soft_counters' || key === 'counters'){
          heroes[idx][key] = val.split(',').map(s=>s.trim()).filter(Boolean);
        } else if(key === 'role'){
          heroes[idx].role = val.trim();
        }
        render();
      };
    } else if(el.tagName === 'SELECT'){
      el.onchange = e => {
        const val = e.target.value;
        if(key === 'group') heroes[idx].group = val;
        else if(key === 'archetype') heroes[idx].archetype = val;
        render();
      };
    } else if(el.tagName === 'BUTTON'){
      el.onclick = e => {
        const act = e.target.dataset.action;
        const i = Number(e.target.dataset.idx);
        if(act === 'rm'){ heroes.splice(i,1); render(); }
        if(act === 'dup'){ heroes.splice(i+1,0, JSON.parse(JSON.stringify(heroes[i]))); render(); }
      };
    }
  });

  // right tally list
  tallyList.innerHTML = '';
  const visibleForTally = heroes.filter(h => roleFilter(h)).sort((a,b)=> (b.total||0) - (a.total||0));
  visibleForTally.forEach(h=>{
    const bd = h._details || {forward:[], reverse:[], total:h.total||0};
    const div = document.createElement('div'); div.style.marginBottom='10px'; div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    const parsed = {compat:[], uncompat:[]}; // compat removed; keep simple structure
    const cp = '';
    const up = '';
    const compatDisplay = '';

    const forwardLines = (bd.forward||[]).map(it=> `<div class="detail-line">${escapeHtml(it.label)} <span style="float:right; font-weight:700">${it.pts>=0? '+'+it.pts: it.pts}</span></div>`).join('');
    const reverseLines = (bd.reverse||[]).map(it=> `<div class="detail-line"><span class="reverse-tag">${escapeHtml(it.label)}</span> <span style="float:right; font-weight:700">${it.pts>=0? '+'+it.pts: it.pts}</span></div>`).join('');
    const showDetails = document.getElementById('debugToggle').checked;

    div.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700" class="${bannedList.includes(h.name)?'banned':''}">${escapeHtml(h.name)} <span class="small muted">(${h.role})</span>${bannedList.find(b=>norm(b)===norm(h.name))?' <span class="banned">(BANNED)</span>':''}</div>
        <div style="text-align:right">
          <div class="${h.disabled? 'score-neg':'score-pos'}" style="font-size:18px; font-weight:800">${h.disabled? 'REMOVED' : (typeof h.total==='number'?h.total:'0')}</div>
          <div class="small muted">${h.group}</div>
        </div>
      </div>
      <div class="tally">
        ${ showDetails ? forwardLines : '' }
        ${ showDetails ? `<div class="detail-line" style="border-top:1px dashed rgba(255,255,255,0.03); margin-top:6px; padding-top:6px"><strong class="small muted">Reverse</strong></div>` : '' }
        ${ showDetails ? reverseLines : '' }
        <div class="tally-row"><div class="k">Counters (list)</div><div class="v" style="font-weight:600">${(h.counters||[]).join(', ') || '-'}</div></div>
        <div class="tally-row"><div class="k">Hard counters (list)</div><div class="v">${(h.hard_counters||[]).join(', ') || '-'}</div></div>
        <div class="tally-row"><div class="k">Soft counters (list)</div><div class="v">${(h.soft_counters||[]).join(', ') || '-'}</div></div>
        <div class="total-hero"><div>Total Points Tallied</div><div>${h.disabled? 'REMOVED' : (h._details && h._details.total>=0 ? '<span class="score-pos">+'+h._details.total+'</span>' : '<span class="score-neg">'+(h._details? h._details.total : h.total)+'</span>')}</div></div>
      </div>
    `;
    tallyList.appendChild(div);
  });

  // recommendation (roamer-only). show pick and glow gold if Roamer tab active
  const pickDecision = decidePick();
  const recEl = recommendationBox;
  if(pickDecision.pickIdx === -1) {
    recEl.innerHTML = `<div class="rec-box">No recommended pick — ${pickDecision.reason}</div>`;
    recEl.classList.remove('glow');
  } else {
    const pick = heroes[pickDecision.pickIdx];
    const isRoamerTab = (activeTab === 'Roamer');
    const glowClass = isRoamerTab ? 'rec-box glow' : 'rec-box';
    recEl.innerHTML = `<div class="${glowClass}" style="${isRoamerTab ? 'border-color: rgba(255,215,0,0.12);' : ''}"><strong style="color:var(--accent)">${pick.name}</strong> — recommended. ${pickDecision.reason}</div>`;
  }
}

// escape helper
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

// live inputs
const allyInput = document.getElementById('allyPicks');
const enemyInput = document.getElementById('enemyPicks');
allyInput.oninput = () => { allyList = parseList(allyInput.value); render(); };
enemyInput.oninput = () => { enemyList = parseList(enemyInput.value); render(); };
// banned heroes live list
const bannedInput = document.getElementById('bannedPicks');
bannedInput.oninput = () => { bannedList = parseList(bannedInput.value); render(); };

// map toggles & other UI (zone listeners removed)
document.getElementById('filter').oninput = render;
document.getElementById('debugToggle').onchange = render;
document.getElementById('clearInputs').onclick = () => {
  allyInput.value = '';
  enemyInput.value = '';
  bannedInput.value = '';
  allyList = [];
  enemyList = [];
  bannedList = [];
  render();
};

// save/load/export
document.getElementById('saveLocal').onclick = () => {
  localStorage.setItem('mlbb_v6', JSON.stringify({heroes, allyList, enemyList, bannedList}));
  alert('Saved.');
};
document.getElementById('loadLocal').onclick = () => {
  const raw = localStorage.getItem('mlbb_v6');
  if(!raw){ alert('No saved data'); return; }
  const obj = JSON.parse(raw);
  heroes = obj.heroes || heroes; allyList = obj.allyList || []; enemyList = obj.enemyList || []; bannedList = obj.bannedList || [];
  allyInput.value = allyList.join(', '); enemyInput.value = enemyList.join(', '); bannedInput.value = bannedList.join(', ');
  render();
};
document.getElementById('exportCsv').onclick = () => {
  const rows = [['Name','Role','Group','Archetype','HardCounters','SoftCounters','Counters','Total','Disabled']];
  heroes.forEach(h=> rows.push([h.name, h.role, h.group, h.archetype||'', (h.hard_counters||[]).join(';'), (h.soft_counters||[]).join(';'), (h.counters||[]).join(';'), h.total||0, !!h.disabled]));
  const csv = rows.map(r=> r.map(c=> `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='mlbb_v6_export.csv'; a.click();
  URL.revokeObjectURL(url);
};

// import handler (JSON or CSV)
document.getElementById('importBackup').onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const text = ev.target.result.trim();
    try {
      // Try JSON first
      const data = JSON.parse(text);
      heroes = data.heroes || heroes;
      allyList = data.allyList || [];
      enemyList = data.enemyList || [];
      bannedList = data.bannedList || [];
      allyInput.value = allyList.join(', ');
      enemyInput.value = enemyList.join(', ');
      bannedInput.value = bannedList.join(', ');
      render();
      alert('Backup imported successfully!');
    } catch {
      // If not JSON, try parsing CSV
      const lines = text.split(/\r?\n/).filter(l => l.trim());
      const headers = lines.shift().split(',').map(h=>h.replace(/"/g,'').trim());
      heroes = lines.map(line => {
        const cols = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(c=>c.replace(/^"|"$/g,''));
        const obj = {};
        headers.forEach((h,i)=> obj[h.trim()] = cols[i]);
        return {
          name: obj.Name || '',
          role: obj.Role || '',
          group: obj.Group || 'Unknown',
          archetype: obj.Archetype || '',
          hard_counters: (obj.HardCounters||'').split(';').filter(Boolean),
          soft_counters: (obj.SoftCounters||'').split(';').filter(Boolean),
          counters: (obj.Counters||'').split(';').filter(Boolean)
        };
      });
      render();
      alert('CSV imported successfully!');
    }
  };
  reader.readAsText(file);
};

// --- Autocomplete support ---
function setupAutocomplete(input) {
  input.addEventListener("input", function() {
    const lastWord = this.value.split(',').pop().trim().toLowerCase();
    const match = heroes.filter(h => h.name.toLowerCase().startsWith(lastWord));
    this.setAttribute("list", input.id + "_list");
    const datalist = document.getElementById(input.id + "_list") || document.createElement("datalist");
    datalist.id = input.id + "_list";
    datalist.innerHTML = match.map(h => `<option value="${h.name}">`).join('');
    document.body.appendChild(datalist);
  });
}
setupAutocomplete(allyInput);
setupAutocomplete(enemyInput);
setupAutocomplete(bannedInput);
// initial render
render();
</script>
</body>
</html>














