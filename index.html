<!-- Save as mlbb-macro-draft-v1.html and open in a browser -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MLBB Draft — Macro + Counter System (v1)</title>
<style>
  :root{
    --bg:#061025; --card:#0b1220; --muted:#9aa6bb; --accent:#66e0b3;
    --danger:#ff6b6b; --good:#66e0b3; --bad:#ff7a7a;
    --gold:#ffd700;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }
  body{background:linear-gradient(180deg,#04101a 0%, #071028 100%); color:#e6eef8; margin:0; padding:18px;}
  .wrap{max-width:1200px;margin:0 auto;}
  h1{margin:0 0 6px;font-size:20px}
  .lead{color:var(--muted); margin:0 0 12px; font-size:13px}
  .card{background:var(--card); padding:12px; border-radius:10px; box-shadow: 0 8px 28px rgba(0,0,0,0.55); margin-bottom:12px}
  .tabs{display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap}
  .tab{padding:8px 12px; border-radius:8px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--muted)}
  .tab.active{background:linear-gradient(90deg, rgba(102,224,179,0.06), transparent); color:var(--accent); border-color:rgba(102,224,179,0.12)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type="text"], input[type="number"], select, textarea {padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit}
  button{background:var(--accent); color:#022; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700}
  button.ghost{background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted)}
  table{width:100%; border-collapse:collapse; margin-top:8px}
  th,td{padding:8px 10px; text-align:left; font-size:13px; vertical-align:top}
  th{color:var(--muted); font-size:12px; text-transform:uppercase}
  tr.removed{opacity:0.45}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  .tally{background:rgba(255,255,255,0.015); border-radius:8px; padding:8px; margin-top:6px}
  .tally-row{display:flex; justify-content:space-between; gap:10px; padding:2px 0; font-size:13px}
  .total-hero{margin-top:8px; padding:8px; border-radius:8px; background:linear-gradient(90deg, rgba(102,224,179,0.04), transparent); font-weight:800; display:flex; justify-content:space-between}
  .score-neg{color:var(--bad)}
  .score-pos{color:var(--good)}
  .grid{display:grid; grid-template-columns: 1fr 420px; gap:12px}
  .hint{font-size:12px;color:var(--muted); margin-top:6px}
  .rec-box{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02); margin-top:8px;}
  #recommendation { position: sticky; bottom: 12px; }
  @media(max-width:980px){ .grid{grid-template-columns: 1fr} .tally{margin-bottom:10px} }
</style>
</head>
<body>
<div class="wrap">
  <h1>MLBB Draft — Macro + Counter System</h1>
  <p class="lead">Pure macro + counter draft. No comfort. You can type multiple archetypes for a hero (e.g. "Pick-Off / Split"). Top 3 recommended picks shown.</p>

  <div class="card">
    <div class="tabs" id="roleTabs"></div>
    <div class="controls" style="margin-top:6px; align-items:center;">
      <div style="min-width:320px">
        <label class="small">Ally picks (live)</label><br/>
        <input id="allyPicks" type="text" placeholder="e.g. Tigreal, Angela, Brody" style="width:100%">
      </div>
      <div style="min-width:320px">
        <label class="small">Enemy picks (live)</label><br/>
        <input id="enemyPicks" type="text" placeholder="e.g. Gatot, Lolita, Hilda" style="width:100%">
      </div>
      <div style="min-width:240px">
        <label class="small">Banned heroes</label><br/>
        <input id="bannedPicks" type="text" placeholder="e.g. Valentina, Franco" style="width:100%">
      </div>
    </div>
    <div class="hint">Macro types (examples): Pick-Off, Teamfight, Split-Push. Use "/" to add multiple archetypes for a hero.</div>
  </div>

  <div class="card">
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px">
      <input type="text" id="filter" placeholder="Filter by name" style="width:260px">
      <div style="flex:1"></div>
      <label class="small" style="margin-right:10px"><input type="checkbox" id="debugToggle"> Show detail lines</label>
      <button id="saveLocal" class="ghost">Save</button>
      <button id="loadLocal" class="ghost">Load</button>
      <button id="exportCsv" class="ghost">Export CSV</button>
      <button id="exportBackup" class="ghost">⬇️ Export Backup</button>
      <input type="file" id="importBackup" accept=".json,.csv" style="display:none">
      <label for="importBackup" class="ghost" style="cursor:pointer;">⬆️ Import Backup/CSV</label>
    </div>

    <div class="grid">
      <div style="overflow:auto; max-height:64vh;">
        <table>
          <thead>
            <tr>
              <th>Hero</th><th>Role</th><th>Group</th><th>Archetype(s)</th><th>Hard Counters</th><th>Soft Counters</th><th>Counters</th><th>Total</th><th></th>
            </tr>
          </thead>
          <tbody id="heroesTable"></tbody>
        </table>

        <div style="margin-top:8px;">
          <button id="addHero" class="ghost">+ Add hero</button>
        </div>
      </div>

      <div>
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <h3 style="margin:0">Tallies — role view</h3>
              <div class="small muted">Tally list shows heroes for active tab (or all for 'All').</div>
            </div>
            <div><button id="clearInputs" class="ghost">Clear Ally/Enemy</button></div>
          </div>

          <div id="tallyList" style="margin-top:12px; max-height:48vh; overflow:auto;"></div>
          <div id="recommendation" style="margin-top:12px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* Macro + Counter draft v1
   - Text archetype for each hero (can contain multiple separated by '/')
   - Hard counters (countered_by) and soft counters fields supported
   - Auto-detect enemy macro; compute hero score using counters + macro rock-paper
   - Shows top 3 picks
*/

// sample heroes (prefill)
let heroes = [
  {name:'Chip', role:'Tank', group:'Meta', macro:'Teamfight', counters:['Alucard'], hard_counters:['Gatot'], soft_counters:[]},
  {name:'Alucard', role:'Assassin', group:'Unknown', macro:'Pick-Off', counters:['Kalea'], hard_counters:['Gatot','Chip'], soft_counters:[]},
  {name:'Gatot', role:'Tank', group:'Meta', macro:'Teamfight', counters:['Alucard'], hard_counters:[], soft_counters:[]},
  {name:'Kalea', role:'Support', group:'Playable', macro:'Teamfight', counters:[], hard_counters:['Alucard'], soft_counters:[]},
  {name:'Franco', role:'Tank', group:'Situational', macro:'Pick-Off', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Angela', role:'Support', group:'Playable', macro:'Teamfight', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Tigreal', role:'Tank', group:'Playable', macro:'Teamfight', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Chou', role:'Fighter', group:'Situational', macro:'Pick-Off / Split-Push', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Badang', role:'Fighter', group:'Situational', macro:'Split-Push', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Granger', role:'Marksman', group:'Meta', macro:'Pick-Off', counters:[], hard_counters:[], soft_counters:[]},
  {name:'Cyclops', role:'Mage', group:'Unknown', macro:'Pick-Off', counters:[], hard_counters:[], soft_counters:[]}
];

const ROLE_TABS = ['All','Tank','Assassin','Fighter','Mage','Marksman','Support','Roamer'];
let activeTab = 'All';
const extraRoamers = ['chou','badang','khaleed','kaja','jawhead','Arlott','Guinevere','Ruby','Helcurt'];

let allyList = [], enemyList = [], bannedList = [];

function norm(s){ return String(s||'').trim().replace(/\s+/g,' ').toLowerCase(); }
function parseList(s){ return String(s||'').split(',').map(x=>x.trim()).filter(Boolean); }
function splitMacros(txt){
  if(!txt) return [];
  return String(txt).split('/').map(x=>x.trim()).filter(Boolean).map(x=>x.toLowerCase());
}

// is roamer hero (keeps old logic)
function isRoamerHero(h){
  const r = norm(h.role);
  if(r==='tank' || r==='support' || r==='roamer') return true;
  if(extraRoamers.includes(norm(h.name))) return true;
  return false;
}

// ---------- core scoring ----------
// scoring constants (easy to edit)
const SCORES = {
  heroCountersEnemy: 3,        // hero directly counters an enemy (+)
  heroSoftCountersEnemy: 1,    // hero soft-counters an enemy (+)
  enemyHardCounter: -4,        // enemy directly hard-counters this hero (-)
  enemySoftCounter: -2,        // enemy soft counters (-)
  macroAdvantage: 2,           // if hero archetype beats enemy macro (rock-paper)
  macroDisadvantage: -2        // if hero archetype is beaten by enemy macro
};

// macro rock-paper relationships (user-defined)
const macroBeats = {
  'pick-off': 'split-push',      // pick-off beats split
  'split-push': 'teamfight',     // split beats teamfight
  'teamfight': 'pick-off'        // teamfight beats pick-off
};

// detect enemy macro from enemyList (count archetypes present)
function detectMacroForSide(list){
  const counts = {}; // macro -> count
  list.forEach(name => {
    const h = heroes.find(x => norm(x.name) === norm(name));
    if(!h) return;
    splitMacros(h.macro||'').forEach(m => {
      counts[m] = (counts[m]||0) + 1;
    });
  });
  // pick the macro with highest count; if tie, pick last two picks' macro majority
  let best = null, bestC = 0;
  for(const [m,c] of Object.entries(counts)){
    if(c > bestC){ best = m; bestC = c; }
  }
  return best; // may be undefined
}

// compute totals for every hero and produce details
function computeTotals(){
  const nameMap = {}; heroes.forEach(h=> nameMap[norm(h.name)] = h);
  const enemyMacro = detectMacroForSide(enemyList);
  const allyMacro = detectMacroForSide(allyList);

  heroes.forEach(h => {
    h._details = { forward:[], reverse:[], total:0 };
    if(bannedList.some(b=>norm(b) === norm(h.name))){ h.disabled = true; h._details.forward.push({label:'BANNED', pts:0}); h.total = 0; return; }
    h.disabled = false;
    let total = 0;

    // For each enemy pick:
    enemyList.forEach(en => {
      const enNorm = norm(en);
      // if hero counters enemy directly (hero.counters contains enemy)
      if(Array.isArray(h.counters) && h.counters.find(x=>norm(x) === enNorm)){
        total += SCORES.heroCountersEnemy;
        h._details.forward.push({label:`Counters ${en}`, pts: SCORES.heroCountersEnemy});
      }
      // hero soft counters enemy (soft_counters field)
      if(Array.isArray(h.soft_counters) && h.soft_counters.find(x=>norm(x) === enNorm)){
        total += SCORES.heroSoftCountersEnemy;
        h._details.forward.push({label:`SoftCounters ${en}`, pts: SCORES.heroSoftCountersEnemy});
      }
      // if enemy hard-counters hero (enemy's counters includes this hero)
      const enHero = nameMap[enNorm];
      if(enHero && Array.isArray(enHero.counters) && enHero.counters.find(x=>norm(x) === norm(h.name))){
        total += SCORES.enemyHardCounter;
        h._details.forward.push({label:`Countered-by ${en}`, pts: SCORES.enemyHardCounter});
      }
      // static: enemy soft-counters this hero (enemy.soft_counters)
      if(enHero && Array.isArray(enHero.soft_counters) && enHero.soft_counters.find(x=>norm(x) === norm(h.name))){
        total += SCORES.enemySoftCounter;
        h._details.forward.push({label:`Soft-countered-by ${en}`, pts: SCORES.enemySoftCounter});
      }
    });

    // Macro interactions: if hero macro beats enemy macro => macroAdvantage
    const heroMacros = splitMacros(h.macro || '');
    if(enemyMacro){
      heroMacros.forEach(hm => {
        const enemyMacroKey = enemyMacro.toLowerCase();
        const isAdv = macroBeats[hm] === enemyMacroKey;
        const isDis = macroBeats[enemyMacroKey] === hm;
        if(isAdv){ total += SCORES.macroAdvantage; h._details.forward.push({label:`Macro adv vs ${enemyMacro}`, pts: SCORES.macroAdvantage}); }
        else if(isDis){ total += SCORES.macroDisadvantage; h._details.forward.push({label:`Macro disadv vs ${enemyMacro}`, pts: SCORES.macroDisadvantage}); }
      });
    }

    // Ally macro synergy: if ally macro exists and hero archetype supports it, give small bonus
    if(allyMacro){
      heroMacros.forEach(hm=>{
        // simple rule: if hero macro == allyMacro, small extra bonus
        if(hm === allyMacro.toLowerCase()){
          total += 1;
          h._details.forward.push({label:`Ally macro synergy (${allyMacro})`, pts: +1});
        }
      });
    }

    h.total = total;
    h._details.total = total;
  });

  return { enemyMacro, allyMacro };
}

// decision: pick among heroes limited to roamer-eligible when Roamer tab active
function decidePick(){
  computeTotals();
  const pool = heroes.filter(h=> !h.disabled && (activeTab === 'All' || (activeTab === 'Roamer' ? isRoamerHero(h) : norm(h.role) === norm(activeTab))));
  if(pool.length === 0) return {picks: []};
  const sorted = pool.slice().sort((a,b)=> b.total - a.total);
  return {picks: sorted.slice(0,3)};
}

// ---------- UI render ----------
const roleTabsEl = document.getElementById('roleTabs');
ROLE_TABS.forEach(tabName => {
  const btn = document.createElement('button');
  btn.className = 'tab' + (tabName===activeTab ? ' active' : '');
  btn.textContent = tabName;
  btn.onclick = () => { activeTab = tabName; document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active')); btn.classList.add('active'); render(); };
  roleTabsEl.appendChild(btn);
});

const heroesTable = document.getElementById('heroesTable');
const tallyList = document.getElementById('tallyList');
const recommendationBox = document.getElementById('recommendation');

function roleFilter(h){
  if(activeTab === 'All') return true;
  if(activeTab === 'Roamer') return isRoamerHero(h);
  return norm(h.role) === norm(activeTab);
}

function render(){
  const filterText = (document.getElementById('filter').value||'').trim().toLowerCase();
  const meta = computeTotals();

  // heroes table
  heroesTable.innerHTML = '';
  const visible = heroes.filter(h => roleFilter(h) && (filterText === '' || norm(h.name).includes(filterText)));
  visible.forEach(h => {
    const i = heroes.indexOf(h); // Step 2: get index in main array
    const tr = document.createElement('tr');
    if(h.disabled) tr.classList.add('removed');
    tr.innerHTML = `
      <td><input data-idx="${i}" data-key="name" value="${escapeHtml(h.name)}" style="width:110px"></td>
      <td><input data-idx="${i}" data-key="role" value="${escapeHtml(h.role)}" style="width:80px"></td>
      <td>
        <select data-idx="${i}" data-key="group">
          <option ${h.group==='Meta'?'selected':''}>Meta</option>
          <option ${h.group==='Situational'?'selected':''}>Situational</option>
          <option ${h.group==='Playable'?'selected':''}>Playable</option>
          <option ${h.group==='Unknown'?'selected':''}>Unknown</option>
        </select>
      </td>
      <td><input data-idx="${i}" data-key="macro" value="${escapeHtml(h.macro||'')}" style="width:140px"></td>
      <td><input data-idx="${i}" data-key="hard_counters" value="${(h.hard_counters||[]).join(', ')}" style="width:120px"></td>
      <td><input data-idx="${i}" data-key="soft_counters" value="${(h.soft_counters||[]).join(', ')}" style="width:120px"></td>
      <td><input data-idx="${i}" data-key="counters" value="${(h.counters||[]).join(', ')}" style="width:120px"></td>
      <td><strong>${typeof h.total === 'number' ? h.total : '0'}</strong></td>
      <td>
        <div style="display:flex; gap:6px;">
          <button data-action="dup" data-idx="${i}" class="ghost">⧉</button>
          <button data-action="rm" data-idx="${i}" class="ghost">✖</button>
        </div>
      </td>
    `;
    heroesTable.appendChild(tr);
  });

  // attach listeners
  heroesTable.querySelectorAll('input,select,button').forEach(el=>{
    const idx = el.dataset.idx; if(typeof idx === 'undefined') return;
    const key = el.dataset.key;
    if(el.tagName === 'INPUT' && el.type === 'text'){
      el.onblur = e => {
        const val = e.target.value;
        if(key === 'name') heroes[idx].name = val;
        else if(key === 'macro') heroes[idx].macro = val;
        else heroes[idx][key] = val.split(',').map(s=>s.trim()).filter(Boolean);
        render();
      };
    } else if(el.tagName === 'SELECT'){
      el.onchange = e => { heroes[idx][key] = e.target.value; render(); };
    } else if(el.tagName === 'BUTTON'){
      el.onclick = e => {
        const act = e.target.dataset.action; const i = Number(e.target.dataset.idx);
        if(act === 'rm'){ heroes.splice(i,1); render(); }
        if(act === 'dup'){ heroes.splice(i+1,0, JSON.parse(JSON.stringify(heroes[i]))); render(); }
      };
    }
  });

  // tally list (right)
  tallyList.innerHTML = '';
  const visibleForTally = heroes.filter(h => roleFilter(h)).sort((a,b)=> (b.total||0) - (a.total||0));
  visibleForTally.forEach(h=>{
    const bd = h._details || {forward:[], reverse:[], total:h.total||0};
    const div = document.createElement('div'); div.style.marginBottom='10px'; div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    const forwardLines = (bd.forward||[]).map(it=> `<div class="detail-line">${escapeHtml(it.label)} <span style="float:right; font-weight:700">${typeof it.pts === 'number' && it.pts>=0 ? '+'+it.pts : it.pts}</span></div>`).join('');
    div.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700">${escapeHtml(h.name)} <span class="small muted">(${h.role})</span></div>
        <div style="text-align:right">
          <div class="${h.disabled? 'score-neg':'score-pos'}" style="font-size:18px; font-weight:800">${h.disabled? 'REMOVED' : (typeof h.total==='number'?h.total:'0')}</div>
          <div class="small muted">${h.group}</div>
        </div>
      </div>
      <div class="tally">
        ${ document.getElementById('debugToggle').checked ? forwardLines : '' }
        <div class="tally-row"><div class="k">Archetype(s)</div><div class="v">${h.macro||'-'}</div></div>
        <div class="tally-row"><div class="k">Counters</div><div class="v">${(h.counters||[]).join(', ') || '-'}</div></div>
        <div class="tally-row"><div class="k">Hard counters</div><div class="v">${(h.hard_counters||[]).join(', ') || '-'}</div></div>
        <div class="tally-row"><div class="k">Soft counters</div><div class="v">${(h.soft_counters||[]).join(', ') || '-'}</div></div>
        <div class="total-hero"><div>Total Points Tallied</div><div>${h.disabled? 'REMOVED' : (h._details && typeof h._details.total==='number' ? (h._details.total>=0 ? '<span class="score-pos">+'+h._details.total+'</span>' : '<span class="score-neg">'+h._details.total+'</span>') : h.total)}</div></div>
      </div>
    `;
    tallyList.appendChild(div);
  });

  // recommendation top 3
  const dec = decidePick();
  if(!dec.picks || dec.picks.length === 0){
    recommendationBox.innerHTML = `<div class="rec-box">No recommendations</div>`;
  } else {
    const html = dec.picks.map((p, i) => {
      return `<div class="rec-box" style="${i===0? 'border:1px solid rgba(102,224,179,0.12);' : ''}"><strong style="color:var(--accent)">${i+1}. ${p.name}</strong> — ${p.total} pts<br/><span class="small muted">${p.role} — ${p.macro||'No archetype'}</span></div>`;
    }).join('');
    recommendationBox.innerHTML = html;
  }
}

// escape helper
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

// inputs
const allyInput = document.getElementById('allyPicks');
const enemyInput = document.getElementById('enemyPicks');
const bannedInput = document.getElementById('bannedPicks');
allyInput.oninput = () => { allyList = parseList(allyInput.value); render(); };
enemyInput.oninput = () => { enemyList = parseList(enemyInput.value); render(); };
bannedInput.oninput = () => { bannedList = parseList(bannedInput.value); render(); };

['zone_grass','zone_river','zone_walls','zone_cloud'].forEach(id => {
  const el = document.getElementById(id);
  if(el) el.onchange = render;
});
document.getElementById('filter').oninput = render;
document.getElementById('debugToggle').onchange = render;
document.getElementById('clearInputs').onclick = () => {
  allyInput.value = ''; enemyInput.value = ''; bannedInput.value = '';
  allyList = []; enemyList = []; bannedList = []; render();
};

// add / save / load / export
document.getElementById('addHero').onclick = () => { heroes.push({name:'New Hero', role:'Unknown', group:'Unknown', macro:'', counters:[], hard_counters:[], soft_counters:[]}); render(); };
document.getElementById('saveLocal').onclick = () => { localStorage.setItem('mlbb_macro_v1', JSON.stringify({heroes, allyList, enemyList, bannedList})); alert('Saved to localStorage.'); };
document.getElementById('loadLocal').onclick = () => {
  const raw = localStorage.getItem('mlbb_macro_v1'); if(!raw){ alert('No saved data'); return; }
  const obj = JSON.parse(raw); heroes = obj.heroes || heroes; allyList = obj.allyList || []; enemyList = obj.enemyList || []; bannedList = obj.bannedList || [];
  allyInput.value = allyList.join(', '); enemyInput.value = enemyList.join(', '); bannedInput.value = bannedList.join(', ');
  render();
};
document.getElementById('exportCsv').onclick = () => {
  const rows = [['Name','Role','Group','Macro','Counters','HardCounters','SoftCounters','Total','Disabled']];
  heroes.forEach(h => rows.push([h.name, h.role, h.group, h.macro || '', (h.counters||[]).join(';'), (h.hard_counters||[]).join(';'), (h.soft_counters||[]).join(';'), h.total||0, !!h.disabled]));
  const csv = rows.map(r=> r.map(c=> `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='mlbb_macro_export.csv'; a.click();
  URL.revokeObjectURL(url);
};
// import handler (JSON or CSV)
document.getElementById('importBackup').onchange = e => {
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ev => {
    const txt = ev.target.result.trim();
    try {
      const data = JSON.parse(txt);
      heroes = data.heroes || heroes;
      allyList = data.allyList || []; enemyList = data.enemyList || []; bannedList = data.bannedList || [];
      allyInput.value = allyList.join(', '); enemyInput.value = enemyList.join(', '); bannedInput.value = bannedList.join(', ');
      render(); alert('JSON imported.');
    } catch {
      // CSV parse (basic)
      const lines = txt.split(/\r?\n/).filter(l=>l.trim());
      const headers = lines.shift().split(',').map(h=>h.replace(/"/g,'').trim());
      heroes = lines.map(line => {
        const cols = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(c=>c.replace(/^"|"$/g,''));
        const obj = {}; headers.forEach((h,i)=> obj[h]=cols[i]);
        return {
          name: obj.Name || '',
          role: obj.Role || '',
          group: obj.Group || 'Unknown',
          macro: obj.Macro || '',
          counters: (obj.Counters||'').split(';').filter(Boolean),
          hard_counters: (obj.HardCounters||'').split(';').filter(Boolean),
          soft_counters: (obj.SoftCounters||'').split(';').filter(Boolean)
        };
      });
      render(); alert('CSV imported.');
    }
  };
  r.readAsText(f);
};

// Autocomplete for ally/enemy (simple datalist)
function setupAutocomplete(input){
  input.addEventListener('input', function(){
    const last = this.value.split(',').pop().trim().toLowerCase();
    const match = heroes.filter(h => norm(h.name).startsWith(last)).slice(0,10);
    this.setAttribute('list', input.id + '_list');
    let datalist = document.getElementById(input.id + '_list');
    if(!datalist){ datalist = document.createElement('datalist'); datalist.id = input.id + '_list'; document.body.appendChild(datalist); }
    datalist.innerHTML = match.map(h => `<option value="${h.name}">`).join('');
  });
}
setupAutocomplete(allyInput); setupAutocomplete(enemyInput); setupAutocomplete(bannedInput);

// initial render
render();
</script>
</body>
</html>


